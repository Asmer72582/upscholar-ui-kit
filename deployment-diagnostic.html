<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Deployment Diagnostic</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            max-width: 1200px; 
            margin: 0 auto; 
            background-color: #f5f5f5;
        }
        .container { 
            display: flex; 
            gap: 20px; 
            flex-wrap: wrap;
        }
        .section { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 300px;
        }
        .video-container { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
            gap: 10px; 
            margin: 20px 0;
        }
        video { 
            width: 100%; 
            height: 200px; 
            background: #000; 
            border-radius: 8px; 
            border: 2px solid #ddd;
        }
        .log { 
            margin: 5px 0; 
            padding: 8px; 
            border-radius: 4px; 
            font-size: 12px; 
            font-family: monospace;
        }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        button { 
            padding: 10px 20px; 
            margin: 5px; 
            font-size: 14px; 
            cursor: pointer; 
            border-radius: 4px; 
            border: none; 
            background-color: #007bff; 
            color: white; 
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .status { 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 4px; 
            font-weight: bold; 
        }
        .connected { background-color: #28a745; color: white; }
        .disconnected { background-color: #dc3545; color: white; }
        .test-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; }
        .test-item { padding: 15px; border: 1px solid #ddd; border-radius: 4px; }
        .test-pass { background-color: #d4edda; border-color: #28a745; }
        .test-fail { background-color: #f8d7da; border-color: #dc3545; }
        .test-pending { background-color: #fff3cd; border-color: #ffc107; }
        h1, h2 { margin-top: 0; color: #333; }
        .diagnostic-info { background-color: #f8f9fa; padding: 15px; border-radius: 4px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>üîç WebRTC Deployment Diagnostic Tool</h1>
    
    <div class="status" id="connectionStatus">Disconnected</div>
    
    <div>
        <button onclick="runFullDiagnostic()">Run Full Diagnostic</button>
        <button onclick="testMediaAccess()">Test Media Access</button>
        <button onclick="testWebRTC()">Test WebRTC Connection</button>
        <button onclick="testSocketIO()">Test Socket.IO</button>
        <button onclick="clearLogs()">Clear Logs</button>
    </div>

    <div class="test-grid" id="testResults">
        <!-- Test results will be populated here -->
    </div>

    <div class="container">
        <div class="section">
            <h2>üìπ Video Streams</h2>
            <div class="video-container" id="videoContainer">
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
        </div>
        
        <div class="section">
            <h2>üìä Connection Logs</h2>
            <div id="logs" style="max-height: 400px; overflow-y: auto;"></div>
        </div>
    </div>

    <div class="section">
        <h2>üîß Environment Information</h2>
        <div id="environmentInfo" class="diagnostic-info"></div>
    </div>

    <script>
        let socket = null;
        let localStream = null;
        let peerConnection = null;
        let dataChannel = null;
        let testResults = {};

        function addLog(message, type = 'info') {
            const logsDiv = document.getElementById('logs');
            const logEntry = document.createElement('div');
            logEntry.className = `log ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        function updateConnectionStatus(connected) {
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.textContent = connected ? 'Connected' : 'Disconnected';
            statusDiv.className = connected ? 'status connected' : 'status disconnected';
        }

        function updateTestResult(testName, status, message) {
            testResults[testName] = { status, message };
            renderTestResults();
        }

        function renderTestResults() {
            const container = document.getElementById('testResults');
            container.innerHTML = '';
            
            Object.entries(testResults).forEach(([testName, result]) => {
                const testDiv = document.createElement('div');
                testDiv.className = `test-item test-${result.status}`;
                testDiv.innerHTML = `
                    <h4>${testName}</h4>
                    <p>${result.message}</p>
                `;
                container.appendChild(testDiv);
            });
        }

        function displayEnvironmentInfo() {
            const info = {
                'User Agent': navigator.userAgent,
                'Platform': navigator.platform,
                'HTTPS': location.protocol === 'https:' ? 'Yes' : 'No',
                'Hostname': location.hostname,
                'WebRTC Support': !!window.RTCPeerConnection ? 'Yes' : 'No',
                'Media Devices API': !!navigator.mediaDevices ? 'Yes' : 'No',
                'Socket.IO Version': typeof io !== 'undefined' ? 'Loaded' : 'Not loaded'
            };

            const infoDiv = document.getElementById('environmentInfo');
            infoDiv.innerHTML = Object.entries(info).map(([key, value]) => 
                `<div><strong>${key}:</strong> ${value}</div>`
            ).join('');
        }

        async function testMediaAccess() {
            addLog('Testing media access...', 'info');
            
            try {
                // Check if mediaDevices is available
                if (!navigator.mediaDevices) {
                    throw new Error('MediaDevices API not available');
                }

                // Check if getUserMedia is available
                if (!navigator.mediaDevices.getUserMedia) {
                    throw new Error('getUserMedia not available');
                }

                // Test video access
                addLog('Requesting camera access...', 'info');
                const videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true 
                });
                
                addLog(`‚úÖ Camera access granted. Tracks: ${videoStream.getTracks().length}`, 'success');
                videoStream.getTracks().forEach(track => {
                    addLog(`  - ${track.kind}: ${track.label} (${track.enabled ? 'enabled' : 'disabled'})`, 'info');
                    track.stop(); // Stop the track to release the camera
                });

                // Test audio access
                addLog('Requesting microphone access...', 'info');
                const audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true 
                });
                
                addLog(`‚úÖ Microphone access granted. Tracks: ${audioStream.getTracks().length}`, 'success');
                audioStream.getTracks().forEach(track => {
                    addLog(`  - ${track.kind}: ${track.label} (${track.enabled ? 'enabled' : 'disabled'})`, 'info');
                    track.stop(); // Stop the track to release the microphone
                });

                updateTestResult('Media Access', 'pass', 'Camera and microphone access granted');
                return true;

            } catch (error) {
                addLog(`‚ùå Media access error: ${error.message}`, 'error');
                updateTestResult('Media Access', 'fail', error.message);
                return false;
            }
        }

        async function testWebRTC() {
            addLog('Testing WebRTC connection...', 'info');
            
            try {
                // Check WebRTC support
                if (!window.RTCPeerConnection) {
                    throw new Error('RTCPeerConnection not supported');
                }

                // Get media stream
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });

                // Display local video
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;

                // Create peer connection
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };

                peerConnection = new RTCPeerConnection(configuration);
                
                // Add local stream
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    addLog(`Added ${track.kind} track to peer connection`, 'info');
                });

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        addLog(`Generated ICE candidate: ${event.candidate.type}`, 'info');
                    } else {
                        addLog('ICE gathering complete', 'success');
                    }
                };

                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    addLog(`Connection state: ${peerConnection.connectionState}`, 'info');
                };

                peerConnection.oniceconnectionstatechange = () => {
                    addLog(`ICE connection state: ${peerConnection.iceConnectionState}`, 'info');
                };

                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                addLog('‚úÖ WebRTC test completed successfully', 'success');
                updateTestResult('WebRTC Connection', 'pass', 'Local peer connection established');
                
                return true;

            } catch (error) {
                addLog(`‚ùå WebRTC test error: ${error.message}`, 'error');
                updateTestResult('WebRTC Connection', 'fail', error.message);
                return false;
            }
        }

        async function testSocketIO() {
            addLog('Testing Socket.IO connection...', 'info');
            
            return new Promise((resolve) => {
                const socketUrl = 'https://upscholar-backend.onrender.com';
                addLog(`Connecting to ${socketUrl}...`, 'info');

                socket = io(socketUrl, {
                    transports: ['websocket', 'polling'],
                    timeout: 10000,
                    forceNew: true,
                    reconnectionAttempts: 3,
                    reconnectionDelay: 1000,
                });

                socket.on('connect', () => {
                    addLog(`‚úÖ Connected to Socket.IO! ID: ${socket.id}`, 'success');
                    updateConnectionStatus(true);
                    updateTestResult('Socket.IO Connection', 'pass', 'Connected successfully');
                    
                    // Test join meeting
                    socket.emit('join-meeting', {
                        meetingId: 'diagnostic-test',
                        userId: socket.id,
                        userName: 'DiagnosticUser',
                        userRole: 'student'
                    });
                    
                    resolve(true);
                });

                socket.on('connect_error', (error) => {
                    addLog(`‚ùå Connection error: ${error.message}`, 'error');
                    updateTestResult('Socket.IO Connection', 'fail', error.message);
                    updateConnectionStatus(false);
                    resolve(false);
                });

                socket.on('connect_timeout', () => {
                    addLog('‚ùå Connection timeout', 'error');
                    updateTestResult('Socket.IO Connection', 'fail', 'Connection timeout');
                    updateConnectionStatus(false);
                    resolve(false);
                });

                socket.on('meeting-joined', (data) => {
                    addLog(`‚úÖ Meeting joined! Participants: ${data.participants.length}`, 'success');
                });
            });
        }

        async function runFullDiagnostic() {
            addLog('üöÄ Starting full diagnostic...', 'info');
            
            // Clear previous results
            testResults = {};
            document.getElementById('testResults').innerHTML = '';
            
            // Display environment info
            displayEnvironmentInfo();
            
            // Run tests sequentially
            const mediaTest = await testMediaAccess();
            if (mediaTest) {
                await testWebRTC();
                await testSocketIO();
            }
            
            // Summary
            const passedTests = Object.values(testResults).filter(r => r.status === 'pass').length;
            const totalTests = Object.keys(testResults).length;
            
            addLog(`üìä Diagnostic complete: ${passedTests}/${totalTests} tests passed`, 
                   passedTests === totalTests ? 'success' : 'warning');
            
            // Provide recommendations
            provideRecommendations();
        }

        function provideRecommendations() {
            const recommendations = [];
            
            if (testResults['Media Access']?.status === 'fail') {
                recommendations.push('üîß Check camera/microphone permissions in browser settings');
                recommendations.push('üîß Ensure HTTPS is enabled for WebRTC functionality');
            }
            
            if (testResults['WebRTC Connection']?.status === 'fail') {
                recommendations.push('üîß Check if WebRTC is supported in your browser');
                recommendations.push('üîß Verify STUN/TURN server configuration');
            }
            
            if (testResults['Socket.IO Connection']?.status === 'fail') {
                recommendations.push('üîß Check if backend server is running');
                recommendations.push('üîß Verify CORS configuration on backend');
            }
            
            if (location.protocol !== 'https:') {
                recommendations.push('‚ö†Ô∏è  WebRTC requires HTTPS for production deployments');
            }
            
            if (recommendations.length > 0) {
                addLog('üí° Recommendations:', 'info');
                recommendations.forEach(rec => addLog(rec, 'info'));
            } else {
                addLog('‚úÖ All systems appear to be working correctly!', 'success');
            }
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
            document.getElementById('testResults').innerHTML = '';
            testResults = {};
        }

        // Cleanup function
        function cleanup() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (peerConnection) {
                peerConnection.close();
            }
            if (socket) {
                socket.disconnect();
            }
        }

        // Handle page unload
        window.addEventListener('beforeunload', cleanup);

        // Auto-run diagnostic on page load
        window.addEventListener('load', () => {
            addLog('WebRTC Diagnostic Tool loaded', 'info');
            displayEnvironmentInfo();
        });
    </script>
</body>
</html>